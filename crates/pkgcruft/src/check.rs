use std::cmp::Ordering;

use once_cell::sync::Lazy;
use pkgcraft::macros::cmp_not_equal;
use pkgcraft::pkg::ebuild;
use pkgcraft::repo::ebuild::Repo;
use pkgcraft::types::{OrderedMap, OrderedSet};
use strum::{AsRefStr, Display, EnumIter, EnumString, IntoEnumIterator, VariantNames};

use crate::report::{Report, ReportKind};
use crate::scope::Scope;
use crate::source::SourceKind;

mod dependency;
mod dropped_keywords;
mod eapi;
mod keywords;
mod metadata;
mod unstable_only;

/// All checks separated by source type.
#[derive(Debug, Copy, Clone)]
pub(crate) enum CheckValue {
    Pkg,
    RawPkg,
    PkgSet,
}

/// All checks separated by source type.
#[derive(
    AsRefStr,
    Display,
    EnumIter,
    EnumString,
    VariantNames,
    Debug,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    Copy,
    Clone,
)]
pub enum Check {
    Dependency,
    DroppedKeywords,
    Eapi,
    Keywords,
    Metadata,
    UnstableOnly,
}

impl Check {
    /// The priority of the check for enabling a deterministic running order.
    pub(crate) fn priority(&self) -> i64 {
        match self {
            Self::Metadata => -9999,
            _ => 0,
        }
    }

    /// Sort checks via priority, then by name.
    pub(crate) fn prioritized(left: &Self, right: &Self) -> Ordering {
        cmp_not_equal!(&left.priority(), &right.priority());
        left.cmp(right)
    }

    pub(crate) fn value(&self) -> CheckValue {
        match self {
            Self::Dependency => CheckValue::Pkg,
            Self::DroppedKeywords => CheckValue::PkgSet,
            Self::Eapi => CheckValue::Pkg,
            Self::Keywords => CheckValue::Pkg,
            Self::Metadata => CheckValue::RawPkg,
            Self::UnstableOnly => CheckValue::PkgSet,
        }
    }

    /// The scope the check runs in.
    pub fn scope(&self) -> Scope {
        match self {
            Self::Dependency => Scope::Version,
            Self::DroppedKeywords => Scope::Package,
            Self::Eapi => Scope::Version,
            Self::Keywords => Scope::Version,
            Self::Metadata => Scope::Version,
            Self::UnstableOnly => Scope::Package,
        }
    }

    /// The source of the values the check runs against.
    pub fn source(&self) -> SourceKind {
        match self {
            Self::Dependency => SourceKind::Ebuild,
            Self::DroppedKeywords => SourceKind::Ebuild,
            Self::Eapi => SourceKind::Ebuild,
            Self::Keywords => SourceKind::Ebuild,
            Self::Metadata => SourceKind::EbuildRaw,
            Self::UnstableOnly => SourceKind::Ebuild,
        }
    }

    /// All the potential report variants generated by the check.
    pub fn reports(self) -> &'static [ReportKind] {
        match self {
            Self::Dependency => dependency::REPORTS,
            Self::DroppedKeywords => dropped_keywords::REPORTS,
            Self::Eapi => eapi::REPORTS,
            Self::Keywords => keywords::REPORTS,
            Self::Metadata => metadata::REPORTS,
            Self::UnstableOnly => unstable_only::REPORTS,
        }
    }

    pub(crate) fn ebuild(self, repo: &Repo) -> EbuildPkgCheck {
        use EbuildPkgCheck::*;
        match self {
            Self::Dependency => Dependency(dependency::Check::new(repo)),
            Self::Eapi => Eapi(eapi::Check::new(repo)),
            Self::Keywords => Keywords(keywords::Check::new(repo)),
            _ => unreachable!("{self} is not an ebuild check"),
        }
    }

    pub(crate) fn ebuild_raw(self, repo: &Repo) -> EbuildRawPkgCheck {
        use EbuildRawPkgCheck::*;
        match self {
            Self::Metadata => Metadata(metadata::Check::new(repo)),
            _ => unreachable!("{self} is not a raw ebuild check"),
        }
    }

    pub(crate) fn ebuild_pkg_set(self, repo: &Repo) -> EbuildPkgSetCheck {
        use EbuildPkgSetCheck::*;
        match self {
            Self::DroppedKeywords => DroppedKeywords(dropped_keywords::Check::new(repo)),
            Self::UnstableOnly => UnstableOnly(unstable_only::Check::new(repo)),
            _ => unreachable!("{self} is not an ebuild pkg set check"),
        }
    }
}

#[derive(Debug)]
pub(crate) enum EbuildPkgCheck<'a> {
    Dependency(dependency::Check<'a>),
    Eapi(eapi::Check<'a>),
    Keywords(keywords::Check<'a>),
}

impl<'a> CheckRun<&ebuild::Pkg<'a>> for EbuildPkgCheck<'a> {
    fn run<F: FnMut(Report)>(&self, pkg: &ebuild::Pkg<'a>, report: F) {
        match self {
            Self::Dependency(c) => c.run(pkg, report),
            Self::Eapi(c) => c.run(pkg, report),
            Self::Keywords(c) => c.run(pkg, report),
        }
    }
}

#[derive(Debug)]
pub(crate) enum EbuildRawPkgCheck<'a> {
    Metadata(metadata::Check<'a>),
}

impl<'a> CheckRun<&ebuild::raw::Pkg<'a>> for EbuildRawPkgCheck<'a> {
    fn run<F: FnMut(Report)>(&self, pkg: &ebuild::raw::Pkg<'a>, report: F) {
        match self {
            Self::Metadata(c) => c.run(pkg, report),
        }
    }
}

#[derive(Debug)]
pub(crate) enum EbuildPkgSetCheck<'a> {
    DroppedKeywords(dropped_keywords::Check<'a>),
    UnstableOnly(unstable_only::Check<'a>),
}

impl<'a> CheckRun<&[ebuild::Pkg<'a>]> for EbuildPkgSetCheck<'a> {
    fn run<F: FnMut(Report)>(&self, pkgs: &[ebuild::Pkg<'a>], report: F) {
        match self {
            Self::DroppedKeywords(c) => c.run(pkgs, report),
            Self::UnstableOnly(c) => c.run(pkgs, report),
        }
    }
}

/// Run a check for a given item sending back any generated reports.
pub(crate) trait CheckRun<T> {
    fn run<F: FnMut(Report)>(&self, item: T, report: F);
}

/// The ordered map of all report variants to the checks that can generate them.
pub static REPORT_CHECKS: Lazy<OrderedMap<ReportKind, OrderedSet<Check>>> = Lazy::new(|| {
    let mut map: OrderedMap<_, OrderedSet<_>> = Check::iter()
        .flat_map(|c| c.reports().iter().copied().map(move |r| (r, c)))
        .collect();
    map.sort_keys();
    map
});

/// The ordered map of all source variants to the checks that use them.
pub static SOURCE_CHECKS: Lazy<OrderedMap<SourceKind, OrderedSet<Check>>> = Lazy::new(|| {
    let mut map: OrderedMap<_, OrderedSet<_>> = Check::iter().map(|c| (c.source(), c)).collect();
    map.sort_keys();
    map
});
