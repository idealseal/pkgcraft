use std::cmp::Ordering;

use camino::Utf8Path;
use once_cell::sync::Lazy;
use pkgcraft::pkg::ebuild;
use pkgcraft::repo::{ebuild::Repo, Repository};
use pkgcraft::types::{OrderedMap, OrderedSet};
use strum::{AsRefStr, Display, EnumIter, EnumString, IntoEnumIterator, VariantNames};

use crate::report::{Report, ReportKind};
use crate::scope::Scope;
use crate::source::SourceKind;

mod dependency;
mod dependency_slot_missing;
mod eapi_stale;
mod eapi_status;
mod keywords;
mod keywords_dropped;
mod live_only;
mod metadata;
mod restrict_test_missing;
mod unstable_only;
mod use_local;

/// Check contexts.
#[derive(Display, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Clone)]
#[strum(serialize_all = "kebab-case")]
pub enum CheckContext {
    Gentoo,
    Optional,
    Overlay,
}

impl CheckContext {
    /// Determine if a context is enabled.
    pub(super) fn enabled(&self, repo: &Repo) -> bool {
        match self {
            Self::Gentoo => repo.name() == "gentoo",
            Self::Optional => false,
            Self::Overlay => repo.masters().next().is_some(),
        }
    }
}

/// Check variants.
#[derive(
    AsRefStr,
    Display,
    EnumIter,
    EnumString,
    VariantNames,
    Debug,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    Copy,
    Clone,
)]
pub enum CheckKind {
    Dependency,
    EapiStale,
    EapiStatus,
    Keywords,
    KeywordsDropped,
    LiveOnly,
    Metadata,
    DependencySlotMissing,
    RestrictTestMissing,
    UnstableOnly,
    UseLocal,
}

impl AsRef<Utf8Path> for CheckKind {
    fn as_ref(&self) -> &Utf8Path {
        let s: &str = self.as_ref();
        Utf8Path::new(s)
    }
}

impl CheckKind {
    /// The priority of the check for enabling a deterministic running order.
    fn priority(&self) -> i64 {
        match self {
            Self::Metadata => -9999,
            _ => 0,
        }
    }

    /// Compare check variants by priority, then by name.
    pub(crate) fn prioritized(left: &Self, right: &Self) -> Ordering {
        left.priority()
            .cmp(&right.priority())
            .then_with(|| left.cmp(right))
    }

    /// The scope the check runs in.
    pub fn scope(&self) -> Scope {
        match self {
            Self::Dependency => Scope::Version,
            Self::DependencySlotMissing => Scope::Version,
            Self::EapiStale => Scope::Package,
            Self::EapiStatus => Scope::Version,
            Self::Keywords => Scope::Version,
            Self::KeywordsDropped => Scope::Package,
            Self::LiveOnly => Scope::Package,
            Self::Metadata => Scope::Version,
            Self::RestrictTestMissing => Scope::Version,
            Self::UnstableOnly => Scope::Package,
            Self::UseLocal => Scope::Package,
        }
    }

    /// The source of the values the check runs against.
    pub fn source(&self) -> SourceKind {
        match self {
            Self::Dependency => SourceKind::Ebuild,
            Self::DependencySlotMissing => SourceKind::Ebuild,
            Self::EapiStale => SourceKind::Ebuild,
            Self::EapiStatus => SourceKind::Ebuild,
            Self::Keywords => SourceKind::Ebuild,
            Self::KeywordsDropped => SourceKind::Ebuild,
            Self::LiveOnly => SourceKind::Ebuild,
            Self::Metadata => SourceKind::EbuildRaw,
            Self::RestrictTestMissing => SourceKind::Ebuild,
            Self::UnstableOnly => SourceKind::Ebuild,
            Self::UseLocal => SourceKind::Ebuild,
        }
    }

    /// All the potential report variants generated by the check.
    pub fn reports(self) -> &'static [ReportKind] {
        match self {
            Self::Dependency => dependency::REPORTS,
            Self::DependencySlotMissing => dependency_slot_missing::REPORTS,
            Self::EapiStale => eapi_stale::REPORTS,
            Self::EapiStatus => eapi_status::REPORTS,
            Self::Keywords => keywords::REPORTS,
            Self::KeywordsDropped => keywords_dropped::REPORTS,
            Self::LiveOnly => live_only::REPORTS,
            Self::Metadata => metadata::REPORTS,
            Self::RestrictTestMissing => restrict_test_missing::REPORTS,
            Self::UnstableOnly => unstable_only::REPORTS,
            Self::UseLocal => use_local::REPORTS,
        }
    }

    /// Create a check runner for a given variant.
    #[rustfmt::skip]
    pub(crate) fn create(self, repo: &Repo) -> Check {
        use Check::*;
        match self {
            Self::Dependency => Dependency(dependency::Check::new(repo)),
            Self::DependencySlotMissing => DependencySlotMissing(dependency_slot_missing::Check::new(repo)),
            Self::EapiStale => EapiStale(eapi_stale::Check),
            Self::EapiStatus => EapiStatus(eapi_status::Check::new(repo)),
            Self::Keywords => Keywords(keywords::Check::new(repo)),
            Self::KeywordsDropped => KeywordsDropped(keywords_dropped::Check::new(repo)),
            Self::LiveOnly => LiveOnly(live_only::Check),
            Self::Metadata => Metadata(metadata::Check::new(repo)),
            Self::RestrictTestMissing => RestrictTestMissing(restrict_test_missing::Check::new()),
            Self::UnstableOnly => UnstableOnly(unstable_only::Check::new(repo)),
            Self::UseLocal => UseLocal(use_local::Check::new(repo)),
        }
    }

    /// Check variant contexts.
    pub fn context(&self) -> &[CheckContext] {
        use CheckContext::*;
        match self {
            Self::LiveOnly | Self::UnstableOnly => &[Gentoo],
            _ => &[],
        }
    }
}

/// Check runner variants.
#[deny(dead_code)]
#[derive(Display, Debug)]
pub(crate) enum Check<'a> {
    Dependency(dependency::Check<'a>),
    DependencySlotMissing(dependency_slot_missing::Check<'a>),
    EapiStale(eapi_stale::Check),
    EapiStatus(eapi_status::Check<'a>),
    Keywords(keywords::Check<'a>),
    KeywordsDropped(keywords_dropped::Check<'a>),
    LiveOnly(live_only::Check),
    Metadata(metadata::Check<'a>),
    RestrictTestMissing(restrict_test_missing::Check),
    UnstableOnly(unstable_only::Check<'a>),
    UseLocal(use_local::Check<'a>),
}

impl<'a> CheckRun<&ebuild::Pkg<'a>> for Check<'a> {
    fn run<F: FnMut(Report)>(&self, pkg: &ebuild::Pkg<'a>, report: F) {
        match self {
            Self::Dependency(c) => c.run(pkg, report),
            Self::DependencySlotMissing(c) => c.run(pkg, report),
            Self::Keywords(c) => c.run(pkg, report),
            Self::EapiStatus(c) => c.run(pkg, report),
            Self::RestrictTestMissing(c) => c.run(pkg, report),
            _ => unreachable!("{self} is not an ebuild check"),
        }
    }
}

impl<'a> CheckRun<&ebuild::raw::Pkg<'a>> for Check<'a> {
    fn run<F: FnMut(Report)>(&self, pkg: &ebuild::raw::Pkg<'a>, report: F) {
        match self {
            Self::Metadata(c) => c.run(pkg, report),
            _ => unreachable!("{self} is not a raw ebuild check"),
        }
    }
}

impl<'a> CheckRun<&[ebuild::Pkg<'a>]> for Check<'a> {
    fn run<F: FnMut(Report)>(&self, pkgs: &[ebuild::Pkg<'a>], report: F) {
        match self {
            Self::EapiStale(c) => c.run(pkgs, report),
            Self::KeywordsDropped(c) => c.run(pkgs, report),
            Self::LiveOnly(c) => c.run(pkgs, report),
            Self::UnstableOnly(c) => c.run(pkgs, report),
            Self::UseLocal(c) => c.run(pkgs, report),
            _ => unreachable!("{self} is not an ebuild pkg set check"),
        }
    }
}

/// Run a check for a given item sending back any generated reports.
pub(crate) trait CheckRun<T> {
    fn run<F: FnMut(Report)>(&self, item: T, report: F);
}

/// The mapping of all report variants to the checks that can generate them.
pub static REPORT_CHECKS: Lazy<OrderedMap<ReportKind, OrderedSet<CheckKind>>> = Lazy::new(|| {
    CheckKind::iter()
        .flat_map(|c| c.reports().iter().copied().map(move |r| (r, c)))
        .collect()
});

/// The mapping of all source variants to the checks that use them.
pub static SOURCE_CHECKS: Lazy<OrderedMap<SourceKind, OrderedSet<CheckKind>>> =
    Lazy::new(|| CheckKind::iter().map(|c| (c.source(), c)).collect());
