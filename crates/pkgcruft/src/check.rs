use std::borrow::Borrow;
use std::cmp::Ordering;
use std::fmt;
use std::hash::{Hash, Hasher};
use std::str::FromStr;

use camino::Utf8Path;
use indexmap::IndexSet;
use once_cell::sync::Lazy;
use pkgcraft::pkg::ebuild;
use pkgcraft::repo::{ebuild::Repo, Repository};
use pkgcraft::types::{OrderedMap, OrderedSet};
use strum::Display;

use crate::report::ReportKind;
use crate::scanner::ReportFilter;
use crate::scope::Scope;
use crate::source::SourceKind;
use crate::Error;

pub(crate) mod dependency;
pub(crate) mod dependency_slot_missing;
pub(crate) mod eapi_stale;
pub(crate) mod eapi_status;
pub(crate) mod keywords;
pub(crate) mod keywords_dropped;
pub(crate) mod live_only;
pub(crate) mod metadata;
pub(crate) mod restrict_test_missing;
pub(crate) mod unstable_only;
pub(crate) mod use_local;

/// Check contexts.
#[derive(Display, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Clone)]
#[strum(serialize_all = "kebab-case")]
pub enum CheckContext {
    Gentoo,
    Optional,
    Overlay,
}

impl CheckContext {
    /// Determine if a context is enabled.
    pub(super) fn enabled(&self, repo: &Repo) -> bool {
        match self {
            Self::Gentoo => repo.name() == "gentoo",
            Self::Optional => false,
            Self::Overlay => repo.masters().next().is_some(),
        }
    }
}

/// Run a check against a given ebuild package version.
pub(crate) trait VersionCheckRun {
    fn run(&self, pkg: &ebuild::Pkg, filter: &mut ReportFilter);
}

/// Run a check against a given ebuild package set.
pub(crate) trait PackageCheckRun {
    fn run(&self, pkg: &[ebuild::Pkg], filter: &mut ReportFilter);
}

/// Run a check against a given raw ebuild package version.
pub(crate) trait RawVersionCheckRun {
    fn run(&self, pkg: &ebuild::raw::Pkg, filter: &mut ReportFilter);
}

/// Registered check.
#[derive(Copy, Clone)]
pub struct Check {
    /// The check identifier.
    pub name: &'static str,

    /// The scope the check runs in.
    pub scope: Scope,

    /// The source of the values the check runs against.
    pub source: SourceKind,

    /// All the potential report variants generated by the check.
    pub reports: &'static [ReportKind],

    /// Check variant contexts.
    pub context: &'static [CheckContext],

    /// The priority of the check for enabling a deterministic running order.
    priority: i64,
}

impl Check {
    /// Return an iterator of all registered checks.
    pub fn iter() -> impl Iterator<Item = Check> {
        CHECKS.iter().copied()
    }

    /// Return an iterator of checks that generate a given report.
    pub fn iter_report(report: &ReportKind) -> impl Iterator<Item = Check> {
        REPORT_CHECKS
            .get(report)
            .unwrap_or_else(|| panic!("no checks for report: {report}"))
            .iter()
            .copied()
    }

    /// Return an iterator of checks that use a given source.
    pub fn iter_source(source: &SourceKind) -> impl Iterator<Item = Check> {
        SOURCE_CHECKS
            .get(source)
            .unwrap_or_else(|| panic!("no checks for source: {source}"))
            .iter()
            .copied()
    }
}

impl fmt::Debug for Check {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Check {{ {} }}", self.name)
    }
}

impl fmt::Display for Check {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.name)
    }
}

impl FromStr for Check {
    type Err = Error;

    fn from_str(s: &str) -> crate::Result<Self> {
        CHECKS
            .get(s)
            .copied()
            .ok_or_else(|| Error::InvalidValue(format!("unknown check: {s}")))
    }
}

impl PartialEq for Check {
    fn eq(&self, other: &Self) -> bool {
        self.name == other.name
    }
}

impl Eq for Check {}

impl Hash for Check {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.name.hash(state);
    }
}

impl Borrow<str> for Check {
    fn borrow(&self) -> &str {
        self.name
    }
}

impl Ord for Check {
    fn cmp(&self, other: &Self) -> Ordering {
        self.priority
            .cmp(&other.priority)
            .then_with(|| self.name.cmp(other.name))
    }
}

impl PartialOrd for Check {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl AsRef<Utf8Path> for Check {
    fn as_ref(&self) -> &Utf8Path {
        Utf8Path::new(self.name)
    }
}

/// The set of all registered checks.
static CHECKS: Lazy<IndexSet<Check>> = Lazy::new(|| {
    [
        dependency::CHECK,
        dependency_slot_missing::CHECK,
        eapi_stale::CHECK,
        eapi_status::CHECK,
        keywords::CHECK,
        keywords_dropped::CHECK,
        live_only::CHECK,
        metadata::CHECK,
        restrict_test_missing::CHECK,
        unstable_only::CHECK,
        use_local::CHECK,
    ]
    .into_iter()
    .collect()
});

/// The mapping of all report variants to the checks that can generate them.
static REPORT_CHECKS: Lazy<OrderedMap<ReportKind, OrderedSet<Check>>> = Lazy::new(|| {
    CHECKS
        .iter()
        .flat_map(|c| c.reports.iter().copied().map(move |r| (r, *c)))
        .collect()
});

/// The mapping of all source variants to the checks that use them.
static SOURCE_CHECKS: Lazy<OrderedMap<SourceKind, OrderedSet<Check>>> =
    Lazy::new(|| CHECKS.iter().map(|c| (c.source, *c)).collect());
